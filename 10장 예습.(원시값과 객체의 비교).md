# 원시값과 객체의 비교

<hr>

자바스크립트의 데이터 타입은 크게 원시타입과 객체 타입으로 구분 할 수있다.

**원시타입**은 (숫자,문자열,불리언,null,undefined,symbol) -값은 변경이 불가능한 값이다. 변수에 값을 할당하면 변수에는 실제 값이 저장된다. 
원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다.
이를 **값의 전달이라** 한다. 

**객체 타입**은(객체,함수,배열)-객체(참조)는 타입의 값,변경이 가능한 값이다. 변수에 할당하면 변수에는 참조값이 저장된다.

객체를 가리키는 변수를 다른 변수에 할당하면 원본 참조 값이 복사되어 전달된다. 이를  **참조(참조값은 객체가 생성된 메모리의 주소 자체이다.))에 의한 전달이라고** 한다.



**원시값**-변경이 불가능한 값./한번 생성된 원시값은 ready only한 값으로 변경할 수없다.

**값을 변경할 수 없다는 것은 무엇을 말하는 것인가?**

1.변수와 값은 구분해서 생각해야한다. 변경이 불가능한다는 것은 값에 대한 진술이다.
값을 변경할 수없다는 것은 재할당의 의미와는 다르다. 변수는 새로운 값을 재할당하여  변수의 값을 변경할 수있다. 변수의 상대개념인 상수는 재할당을 금지한다. 상수도 변수이다. 변수는 언제든지 재할당을 통해서 변수 값을 재할당 할 수있지만 상수는 단 한번만 할당이 허용된다. 
하지만 상수와 변경이 불가능한 값을 동일시하는 것은 곤란하다. 원시값은 어떤일이 있어도 변경이 불가능한 값이기 때문에 신뢰성이 보장된다.
따라서 원시값은 변경이 불가능한 값이기 때문에 원시값을 할당한 변수를 재할당을 하면 원시값은 자체를 수정하는 것이 아니라  새로운 메모리에 공간을 확보하고 재할당한 값을 저장한후에   새롭게 재당한 원시값 가르키고, 메모리공간주소를 변경한다.
이러한 특성이 불변성이다.

## 1.2문자열과 불변성

문자열은 0개이상인 문자들의 집합을 말한다.1개의 문자는 2byte메모리 공간에 저장된다. 따라서 문자열은 몇개의 문자로 이루어졌는지에 대해서 메모리 공간의 크기가 결정된다.
문자열은 유사배열 객체(마치 배열처럼 인덱스로 프로퍼티의 값에 접근할 수있고,length 프로퍼티를 갖는 객체를 말한다.)이므로 배열과 유사하게 각 문자에 접근할 수있다.

문자열은 원시값이므로 이미 생성된 문자열의 일부를 변경하더라도 반영되지 않는다. 따라서 예기치 못한 변경으로 자유롭다. 이는 신뢰성을 보장한다. 또한 새로운 문자열을 재할당하는 것은 가능하다. 이는 새로운 문자열을 변경하는 것이 아니라 새롭게 재할당하는것이다.

## 1.3.값에 전달

변수에 변수를 할당하는 경우 ,할당되는 변수가 원시값을 갖는 변수라면 할당받는 변수에는 할당되는 변수의 원시값이 복사되어 전달된다. 이를  값에 의한 전달이라 한다.
그러나 값은 같을 지라도 다른 메모리에 저장된 별개의 값이다.따라서 할당받은 변수에 값은 변경해도 원래 변수에 영향을 주지 않는다.

중요한 것은 변수에 원시값을 갖는 변수를 할당하는 경우, 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이며 서로 간섭할 수 없다는 것이다.

### 객체 

객체는 프로퍼티 개수가 정해저있지 않고 동적으로 추가되고 삭제되어질 수있다. 또한 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시값과 같이 확보해야할 메모리의  공간의 크기를 사전에 정해둘 수 없다.

### **자바스크립트의 객체관리 방식*

자바스크립트는 클래스 없이 객체를 생성  할 수있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메소드를 추가할 수 있다. 자바스크리트 엔진은 객체의 프로퍼티 값의 위치를 메모리에 저장하기 위해 해시 함수기반의 유사 딕셔너리 구조를 사용한다.(key-value)/(index-value)

## 2.1.변경가능한 값

<hr>

객체(참조)타입의 값,즉 객체는 변경이 가능한 값이다.
원시값을 할당한 변수는 원시값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수는 참조값을 값으로 갖는다. 
 **참조값은 생성된 객체가 저장된 메모리 공간의 주소 자체이다**

 객체를 할당한 변수는 확보된 메모리 공간에 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어있다. 이를 참조값이라고 한다. 변수는 이 참조 값을 통해서 객체에 접근할 수 있다.
객체를 할당한 변수는 객체를 참조하고 있다. 변수는 객체를 가리키고 있다고 표현한다.

**원시값은 변경이 불가능하기때문에  원시값을 가지는 변수를 재할당하여 새로운 메모리 주소에 원시값을 새롭게 생성해야하지만, 객체를 변경할 수있는 값이기 때문에 저장된 객체를 직접 수정할 수 있다.  또한 참조값은 변경되지 않는다.(참조값은 객체가 생성된 메모리의 주소 자체이다.)**

**앝은 복사**:객체를 프로퍼티 값으로 갖는 경우에 한단계까지만 복사하는 것을 의미
**깊은 복사**: 객체가 중첩되어있는 객체까지 모두 복사하는 것을 의미한다.
얕은 복사와 깉은 복사는 모두 복사로 생성된 객체이기에 원본과는 다른객체이다. 원본과 복사본은 참조 값이 다른 별개의 객체이다.

메모리를 효율적으로 사용하기 위해,객체를 복사하고 생성하는 비용을 절약하기 위해서 변경가능한 값으로 디자인 되었다. 객체는 구조적인 단점에 따른 부작용이 있는데 이는 원시값과 다르게 여러개의 식별자가 하나의 객체를 공유하고 있다는 것이다.

## 2.2참조에 의한 전달

여개의 식별자가 하나의 객체를 공유 할 수 잇다는 것이 무엇을 의미하는 지,이로인해 어떤 부작용이 발생하는 지 확인해 보자.

원본 변수를 다른 변수에(사본에) 할당을 하면  참조값이 그래로 복사가 된다.
이를 참조에 의한 전달이라고 한다.

**원본** 을 **사본**에 할당하면은 원본의 참조값을 복사하여 사본에 저장한다. 이렇게 되면서 원본과 사본은 정확히 값은 참조 값을 가지게 되므로 ,한쪽에서 변경을 하면(새로운 객체를 재할당하는 것이 아닌 객체의 프로퍼티 값을 변경,추가,삭제)를 하면 서로 영향을 주고 받게 된다는  부작용 발생하게 된다.

var person1={name:'lee'}; var person2={name:'lee'}
console.log(person1===person2)//false
console.log(person1.name===person2.name)//true











